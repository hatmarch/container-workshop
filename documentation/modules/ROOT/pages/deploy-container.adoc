include::_attributes.adoc[]

:OCP_PROJECT: {USER}

= Containers and OpenShift
:navtitle: Containers and OpenShift

== Login to OpenShift

First, let's log into OpenShift your OpenShift cluster.  Choose the tab that is most appropriate to your situation.  If you are unsure, ask your lab techs.

[tabs]
====
Provisioned::
+
--
. You should be able to reach the OpenShift cluster provisioned for this lab link:https://console-openshift-console.apps.{CLUSTER_SUBDOMAIN}/[here^]
. You should be met with a login challenge screen
+
image::openshift-login-challenge.png[]
+
. Enter the following details
** *Username*: {USER}
** *Password*: openshift
 
--
OpenShift Developer Sandox::
+
--
Coming Soon!
--
====

If you've logged in successfully, you should find yourself on the (empty) start page for the Developer Perspective one the `{OCP_PROJECT}` projectfootnote:[_project_ is an OpenShift specific term.  For the purposes of this lab you can think of is as synonymous with the Kubernetes concept of a _namespace]

image::ocp-developer-perspective.png[]

=== Console Login

For this section we're going to want to issue commands to OpenShift from the commandline.  OpenShift has a cli called `oc` footnote:[`oc` is built on top of `kubectl`, the generic Kubernetes CLI.  Any command you can issue with `kubectl` you can issue with `oc`, but `oc` builds upon `kubectl` with OpenShift specific commands, such as `oc login`] which we will leverage.

Here again, choose the proper tab for your setup

[tabs]
====
Provisioned::
+
--
. From the (CodeServer) terminal, enter the following command to log into OpenShift
+
[.console-input]
[source,bash,subs="+macros,+attributes"]
----
oc login https://api.{CLUSTER_SUBDOMAIN}:6443 \#<.>
    --username {USER} \
    --password 'openshift'
----
<.> This is the URL of the REST api for OpenShift with which the CLI interacts
+
.Insecure connections
****
If you are met the with following question in the console

[.console-output]
[source,bash,subs="+macros,+attributes"]
----
The server uses a certificate signed by an unknown authority.
You can bypass the certificate check, but any data you send to the server could be intercepted by others.
Use insecure connections? (y/n): 
----

You can safely answer `y` (yes) at the prompt
****
--
OpenShift Developer Sandbox::
+
--
Coming soon
--
====

If you have logged on successfully, running the following command: 

[.console-input]
[source,bash,subs="+macros,+attributes"]
----
oc whoami
----

Should yield the following output

[.console-output]
[source,bash,subs="+macros,+attributes"]
----
{USER}
----

== Simple Container Deployment

Let's go back to the container that we finished xref::build-your-own-container.adoc#finished_container[here,window=_blank] and look at what a simple deployment to the `{OCP_PROJECT}` project.

=== Container Registry

In order to be able to run an image in OpenShift or Kubernetes we need to put our image somewhere we're OpenShift can find it.  This usually involves uplaoding the image to either a public or private container registry.  Public registries include Red Hat's link:quay.io[quay.io^] and Docker's link:https://hub.docker.com/[Docker Hub^]

One of the features that OpenShift adds to Kubernetes is an inbuilt container registry called an ImageStream.  We're going to create an ImageStream to upload our container to where OpenShift can find it.

We can create the image stream either from the OpenShift Console (UI) or from the terminal (command line).  Choose one of the following tabs

[tabs]
====
Terminal::
+
--

. Enter the following command
+
[.console-input]
[source,bash,subs="+macros,+attributes"]
----
oc create imagestream \#<.>
    -n {OCP_PROJECT} \#<.>
    {ocp_secure_image_name} #<.>
----
<.> `ImageStream` is an OpenShift specific Kubernetes resource that represents a project specific container registry
<.> This is the namespace the ImageStream should be bound to
<.> This is the name of the image registry we want to create

--
OpenShift Console::
+
--
_Coming Soon_
--
====

. With our ImageStream created, we can find our registry endpoint with this command
+
[.console-input]
[source,bash,subs="+macros,+attributes"]
----
OCP_REGISTRY_URL=$(oc get imagestream {ocp_secure_imagestream_name} \
    -n student1 \
    -o jsonpath='{.status.publicDockerImageRepository}') #<.>
----
<.> `-o` is used to specify the output type.  In this case we specify `jsonpath` which means give the output as JSON and then act as if it were piped to `jq -r` meaning we specify the field in the JSON we are looking for
+
. Once we have the `publicDockerImageRepository` we can use podman to login into it with our OpenShift credentials
+
[.console-input]
[source,bash,subs="+macros,+attributes"]
----
podman login \
    pass:[${OCP_REGISTRY_URL}] \
    --username {USER} \
    --password "$(oc whoami -t)" #<.>
----
<.> You must log into imagestream registries using a token and not your user's password.  `oc whoami -t` returns the currently active token for a given OpenShift session
+
. This should yield the following output, which indicates that you've authenticated with the ImageStream internal registry
+
[.console-output]
[source,bash,subs="+macros,+attributes"]
----
Login Succeeded!
----
+
. Now we're going to use a new `podman` command called `tag` to associate our local image with an image that could exist in our ImageStream registry
+
[.console-input]
[source,bash,subs="+macros,+attributes"]
----
podman tag {apache-server-containerfile-image} \
    pass:[${OCP_REGISTRY_URL}]:latest 
----
+ 
. Once tagged, we should now be able to push this image into the ImageStream using the `podman push` command 
+
[.console-input]
[source,bash,subs="+macros,+attributes"]
----
podman push ${OCP_REGISTRY_URL}:latest
----
+
. You should see output similar to the following
+
[.console-output]
[source,bash,subs="+macros,+attributes"]
----
Getting image source signatures
Copying blob 1d505cb9245a done  
Copying blob 9e12a51e507a done  
Copying blob 01d2fb866535 done  
Copying config f8b584bce6 done  
Writing manifest to image destination
Storing signatures
----

Now we have our image in a place where we can refer to it

=== Run an image

The simplest way to get a container image up and running in OpenShift is with the `oc run` command.  This will create what's called a `pod` to house our container that runs based on the image definition we just uploaded to the ImageStream

. Run the following command from the Code Server terminal
+
[.console-input]
[source,bash,subs="+macros,+attributes"]
----
oc run \
    my-web-server \#<.>
    -n {OCP_PROJECT} \
    --image {ocp_secure_image_name}:latest #<.>
----
<.> The name that will be given to the pod
<.> `--image` in this case assumes the ImageStream for the project specified by `-n`, which is why can use the  `my-web-server:latest` as a shorthand.  This has the added benefit of handling the login to the imagestream for us (given that the image stream acts more like a private repo in that it requires login for image pull)
+
[.console-output]
[source,bash,subs="+macros,+attributes"]
----
pod/my-web-server created
----
+
. Switch to the OpenShift Console (UI) and look at the developer perpective for your project.  You should see the pod running

