include::_attributes.adoc[]

= Containers and Persistence

Containers are meant to be run as "immutable" instances that exactly match the state of the image that they were started from (as we saw in the last section).  However, there many scenarios where adjusting this otherwise immutable state would be useful such as:

* Having the containers running the same image run differently in different environments (e.g. Preproduction vs Production environments)
** For instance, having applications in the container consume different configuration data based on the environment
* Persisting state beyond the life of the container (e.g. Databases, logfiles)
* Sharing state between containers  

Luckily, containers have facilities to support all these things.  We'll explore some of these features in this section

[#mounting_volumes]
== Mounting Volumes

Whilst containers have their own immutable filesystem, it is possible for containers to "mount" volumes that are outside the container's filesystem.  This opens up opportunities for persisting state on those mounted filesystems or sharing that state with processes outside the container.

[TIP]
====
This can also open a number of security concerns for our containers as we'll see later on!
====

Going back to our website, let's see how we can run our webserver in such a way that we can persist our {guestbook-record-file}.  Our strategy will be to have the container write to a file that is **local to our VM filesystem** instead of into the container's filesystem.

. First, let's remove (and stop) any container that we might have running (such as the container based on `{apache-committed-container-image}`): 
+
[.console-input]
[source,bash,subs="+macros,+attributes"]
----
podman rm -a \
    --force #<.>
----
<.> This is a bit of a violent way to stop and remove a running container.  It's a little bit like using `kill -9` to stop a linux process.
+
. Since we're going to use the VM's filesystem for persistence, we don't need to use our committed image (`{apache-committed-container-image}`) anymore, especially now that we've copied off of it the `{guestbook-record-file}` we'd like to use.  Let's remove that image from our machinefootnote:[You can keep images around if you'd like, but like VM snapshots they take of space on the host filesystem.  Generally it's good practice to remove images from your system that you are no longer using]
+
[.console-input]
[source,bash,subs="+macros,+attributes"]
----
podman rmi \#<.>
   localhost/{apache-committed-container-image} #<.>
----
<.> `rmi` stands for _remove image_.  Don't confuse this with `rm` which has to do with removing containers that are stopped
<.> We're removing based on the image name.  We could also remove by `IMAGE ID`
+
. If the command worked, you should see output like the following: 
+
[.console-output]
[source,bash,subs="+macros,+attributes"]
----
Untagged: localhost/{apache-committed-container-image}:latest
Deleted: {commit-container-image-id-long}
----
+
. Next, we'll [#podman_run_httpd]#run# our initial `{apache-server-image-insecure}` image, but this time with an additional `-v` option
+
[.console-input]
[source,bash,subs="+macros,+attributes"]
----
podman run \
    -d \
    -p 8081:80/tcp \
    --name {apache-server-container-name} \
    -v {container-workshop-exercise-path}:/var/log/www:Z \#<.>
    {apache-server-image-insecure}
----
<.> The format of the volume mount option is <host_path>:<container_path>:<options>.  In our case, we're mounting `{container-workshop-exercise-path}` at `/var/log/www` in the container.  The `Z` option is for SELinux and gives the container permission to write to the folder

[#test_mount]
== Testing the Volume Mount

Now that the container is running mounted to the `{container-workshop-exercise-path}` on the host, we should be able to test out its effects

. Make sure you have the `{guestbook-record-file}` open in VSCode in an editor pane adject to the *Browser Preview* pane as shown
+
image::mounted-visitor-info-setup.png[]
+
. Next, navigate to the guestbook URL by navigating pasting this in the *Browser Preview*
+
[.console-input]
[source,subs="+macros,+attributes"]
----
localhost:8081/hello.html
----
+
. Once there, enter a name (such as _Danny_) into the name field and press Submit
. You should now see _Danny_ (or whatever name you entered) added to the `{guestbook-record-file}` on the host in real time
+
.See visitors on the host
image::mounted-visitor-info.png[]

[#containerized_databases]
== Containerized Databases

[WARNING]
====
This section is not yet completed
====

Given that containers have the ability to mount other (persistent) filesystems, database servers also become candidates for running in containers.  (Non ephemeral) containerized databases use volume mounts for their `data` directory where they write and persist the contents of the database to the filesystem.

. Start your database by running the following command:
+
[.console-input]
[source,bash,subs="+macros,+attributes"]
----
podman run \
    --rm #<.>
    --name mysql_database #<.>
    -e MYSQL_USER=user -e MYSQL_PASSWORD=pass -e MYSQL_DATABASE=db <.>
    -p 3306:3306 
    quay.io/mhildenb/mysql-80
----
<.> This means the container should be removed once stopped
<.> Instead of referring to the container by its `Container ID` we can provide a name by which we'd like to address the container
<.> These are environment variables that we would like to be made available within the container.  In this instance, these are all environment variables that MySQL uses to set itself up
+
. The terminal should be taken over with log output from the container.  This is because we did not run the container in "daemon mode" and instead it is running in the foreground of our terminal.
. Open a second terminal to the side by hitting the terminal split button 
+
.Terminal split button
image::terminal-split.png[]
+
. Observe the running container image by running the `podman ps` command
+
[.console-input]
[source,bash,subs="+macros,+attributes"]
----
podman ps
----
+
[.console-output]
[source,bash,subs="+macros,+attributes"]
----
CONTAINER ID  IMAGE                             COMMAND               CREATED         STATUS             PORTS                   NAMES
e658d0e1d5c1  quay.io/mhildenb/mysql-80:latest  run-mysqld --defa...  13 minutes ago  Up 13 minutes ago  0.0.0.0:3306->3306/tcp  mysql_database <.>
----
<.> Notice that this is the name we assigned the container above

=== Create Database
. Let's create our database providing the output of a .sql file to a mysql cli that is running in the container.  To do this we will use the `podman exec` command
+
[.console-input]
[source,bash,subs="+macros,+attributes"]
----
cat /home/{user}/container-workshop/sql/example_database.sql | \#<.>
    podman exec \#<.>
    -i \#<.>
    mysql_database \#<.>
    mysql -u user -p'pass' -D db #<.>
----
<.> output the contents of the .sql file that creates the example database to STDIN
<.> Run a command in a (running) container
<.> interactive: makes STDIN available to whatever command we are exec'ing
<.> The name (or `Container ID`) of the running container where we want to run the command
<.> The command that we mean to run